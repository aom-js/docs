# Использование веб-сокетов

Использование веб-сокетов в контексте контроллеров `aom` позволяет создавать
управляемые подключения, данные в которые могут быть переданы как из других контроллеров,
так и из схем данных. Таким образом могут быть построены сложные сигнальные конструкции,
сообщаюшие об изменениях в данных, которые требуется получить заново.

В общем смысле методология применения сокетов сводится к следующей логике: подключемый сокет является
сигнальным элементом, появление данных в которых означает, что из того эндпоинта, к которому он подключен,
следует заново получить данные, и применить их типовым для этого процесса образом.

Например, это может быть применимо для того, чтобы сообщить определенным пользователям, что у них
появились новые уведомления, и следует обновить значения в компоненте, визуализирующую данные оттуда.
Или что обновилась страница, с которой могут одновременно взаимодействовать пользователи по фиксированной
ссылке, и следует обновить её, загрузив новые данные (например, новые сообщения в комнате чата).

Сами данные в сокете никак не интерпретируются, наиболее частый состава данных в сокете: текущая дата
выполнения операции. В общем смысле значение может служить для компоненты пользовательского приложения
в качестве инструкции вида "получить данные после указанной даты"

## Реализация обмена сообщениями

Обмен сообщениями между серверов и сокетом происходит за счет использования специальной компоненты
подключенной к `kafka`, и позволяющая локализовать множество отправителей и единственного получателя
всех сообщений. В стандартном примере `aom-js/demo` используется базовая реализация, применимая для
большинства случаев.

На базе этой компоненты создается пара `producer/consumer`, которые в дальнейшем используется в
схемах и контроллерах.

```ts
// `api/items/sockets.ts`

import { KafkaSockets } from "kafka/sockets";
import { Sockets } from "common/controllers";

export const socketsDataStore = new Sockets();

export const ItemsDataSocketsEmitter = KafkaSockets({
  sockets: socketsDataStore,
  name: "ItemsData",
});

export const socketsDocumentStore = new Sockets();

export const ItemsDocumentSocketsEmitter = KafkaSockets({
  sockets: socketsDocumentStore,
  name: "ItemsDocument",
});
```

Созданные `store` используются в контроллерах данных, обогащая класс, который затем может быть подключен
к `middleware` контроллера `WebSockets`.

```ts
// `api/items/index.ts`
import { controllers } from "models";
import { WebSockets } from "common/controllers";
import { socketsDataStore } from "./sockets";

@Controller()
@AddTag("Товары")
@Bridge(`/item_${Item}`, Item)
export class Items extends controllers.Items.data() {
  static sockets = socketsDataStore.server();

  @Get()
  @Summary("Список предметов")
  @Use(WebSockets.Init)
  @UseNext(Items.TotalData)
  static async Index(@This() self: Items, @Next() next: NextFunction) {
    await self.getData();
    return next();
  }
  // ...
}
```

Чтобы отправить сообщение в этот сокет, необходимо вызвать функцию `ItemsDataSocketsEmitter`. Появление
значения в нем прокинет его в подключенный сокет, и в зависимости от аргументации вызываемой функции.
Первым аргументом всегда должно быть отправляемое сообщение, а вторым - идентификатор получателя.

Штатное подключение сокета через `middleware`-метод `WebSockets.Init` группирует подключения по `userId`,
делая тем самым возможность нескольких параллельных сессий пользователя, который может пользоваться
несколькими устройствами, и в разных случаях смотреть на разный состав данных.

При вызове вида `ItemsDataSocketsEmitter(new Date)` сообщение будет отправлено всем
пользователям, которые слушают данный сокет. А при вызове `ItemsDataSocketsEmitter(new Date, userId)`
отправка сообщения произойдет только в сокеты указанного пользователя. Такое оповещение удобно в случаях
появления новых системных уведомлений, которые ему следует прочесть.

## Параметрическое подключение к сокету

Для подключения к специфической ссылке следует, внутри которой будет происходить рассылка сообщений тем,
кто к ней подключен, используется расширенный подход, который опирается на контекст переменных контроллера.

```ts
// `api/items/item.ts`
import { controllers } from "models";
import { WebSockets } from "common/controllers";
import { socketsDocumentStore } from "./sockets";

@Controller()
export class Item extends controllers.Items.document("itemId") {
  static sockets = socketsDocumentStore.server();

  // указание, какое имя параметра следует использовать, чтобы опереться на его значение
  static socketsParam = () => Item.paramId;

  @Get()
  @Endpoint()
  @Use(WebSockets.Param)
  @Summary("Информация о товаре")
  @Responses(Item.toJSON("Товар"))
  static async Index(@This(Item) item: Item) {
    return item.document;
  }

  // ...
}
```

Таким образом, что группировка данных о подключениях производится не на основании `userId` значения
пользователя, на основании значения `itemId`, характеризующего адрес страницы подключения.

Таким образом, что если указать это значение в качестве второго аргумента в `ItemsDocumentSocketsEmitter`
то это отправит сообщение всем пользователям, которые подключены к сокету именно по данному адресу
с используемым значением идентификатора.

Эта механика может использоваться, например, при создании реактивных визуалов и форм, которые следует обновить,
если появились новые данные по тому же адресу: сообщения в комнате чата, форма документа, информация о товаре
и другие похожие кейсы.
